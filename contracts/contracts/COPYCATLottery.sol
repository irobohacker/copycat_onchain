// SPDX-License-Identifier: Apache 2
pragma solidity ^0.8.0;

// Import the entropy SDK in order to interact with the entropy contracts
import "@pythnetwork/entropy-sdk-solidity/IEntropyV2.sol";
import "@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol";
// Import the EntropyStructsV2 contract to get the ProviderInfo struct
import "@pythnetwork/entropy-sdk-solidity/EntropyStructsV2.sol";

library LotteryErrors {
    error InsufficientFee();
    error LotteryNotActive();
    error LotteryAlreadyEnded();
    error NoParticipants();
    error NotOwner();
    error InvalidLotteryId();
    error AlreadyParticipated();
    error LotteryInProgress();
}

/// COPYCAT Lottery contract using Pyth Entropy for fair random number generation.
/// Users can participate in lottery rounds by paying an entry fee.
/// The lottery uses Pyth Entropy to ensure fair and verifiable randomness.
/// Winners are selected based on the random number generated by the entropy provider.
contract COPYCATLottery is IEntropyConsumer {
    // Events
    event LotteryCreated(uint256 indexed lotteryId, uint256 entryFee, uint256 maxParticipants, uint256 duration);
    event LotteryJoined(uint256 indexed lotteryId, address indexed participant, uint256 participantCount);
    event LotteryEnded(uint256 indexed lotteryId, address indexed winner, uint256 prizeAmount, uint256 sequenceNumber);
    event RandomNumberRequested(uint256 indexed lotteryId, uint64 sequenceNumber);
    event PrizeClaimed(uint256 indexed lotteryId, address indexed winner, uint256 amount);

    // Lottery structure
    struct Lottery {
        uint256 lotteryId;
        uint256 entryFee;
        uint256 maxParticipants;
        uint256 startTime;
        uint256 endTime;
        uint256 prizePool;
        address[] participants;
        address winner;
        bool isActive;
        bool isEnded;
        uint64 sequenceNumber;
        bool randomNumberReceived;
    }

    // State variables
    IEntropyV2 private entropy;
    address private entropyProvider;
    address public owner;
    uint256 public nextLotteryId;
    uint256 public totalLotteries;
    uint256 public totalPrizesDistributed;
    
    // Lottery mappings
    mapping(uint256 => Lottery) public lotteries;
    mapping(uint256 => mapping(address => bool)) public hasParticipated;
    mapping(address => uint256) public userWinnings;
    mapping(address => uint256) public userParticipations;

    // Constants
    uint256 public constant MIN_ENTRY_FEE = 0.001 ether;
    uint256 public constant MAX_ENTRY_FEE = 1 ether;
    uint256 public constant MIN_PARTICIPANTS = 2;
    uint256 public constant MAX_PARTICIPANTS = 1000;
    uint256 public constant MIN_DURATION = 1 hours;
    uint256 public constant MAX_DURATION = 7 days;

    constructor(address _entropy, address _entropyProvider) {
        entropy = IEntropyV2(_entropy);
        entropyProvider = _entropyProvider;
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert LotteryErrors.NotOwner();
        }
        _;
    }

    modifier lotteryExists(uint256 _lotteryId) {
        if (_lotteryId >= nextLotteryId) {
            revert LotteryErrors.InvalidLotteryId();
        }
        _;
    }

    /// Create a new lottery
    function createLottery(
        uint256 _entryFee,
        uint256 _maxParticipants,
        uint256 _duration
    ) external onlyOwner returns (uint256) {
        if (_entryFee < MIN_ENTRY_FEE || _entryFee > MAX_ENTRY_FEE) {
            revert LotteryErrors.InsufficientFee();
        }
        if (_maxParticipants < MIN_PARTICIPANTS || _maxParticipants > MAX_PARTICIPANTS) {
            revert LotteryErrors.InvalidLotteryId();
        }
        if (_duration < MIN_DURATION || _duration > MAX_DURATION) {
            revert LotteryErrors.InvalidLotteryId();
        }

        uint256 lotteryId = nextLotteryId++;
        totalLotteries++;

        Lottery storage lottery = lotteries[lotteryId];
        lottery.lotteryId = lotteryId;
        lottery.entryFee = _entryFee;
        lottery.maxParticipants = _maxParticipants;
        lottery.startTime = block.timestamp;
        lottery.endTime = block.timestamp + _duration;
        lottery.isActive = true;
        lottery.isEnded = false;

        emit LotteryCreated(lotteryId, _entryFee, _maxParticipants, _duration);
        return lotteryId;
    }

    /// Join a lottery by paying the entry fee
    function joinLottery(uint256 _lotteryId) external payable lotteryExists(_lotteryId) {
        Lottery storage lottery = lotteries[_lotteryId];
        
        if (!lottery.isActive) {
            revert LotteryErrors.LotteryNotActive();
        }
        if (block.timestamp >= lottery.endTime) {
            revert LotteryErrors.LotteryAlreadyEnded();
        }
        if (hasParticipated[_lotteryId][msg.sender]) {
            revert LotteryErrors.AlreadyParticipated();
        }
        if (lottery.participants.length >= lottery.maxParticipants) {
            revert LotteryErrors.LotteryInProgress();
        }
        if (msg.value != lottery.entryFee) {
            revert LotteryErrors.InsufficientFee();
        }

        lottery.participants.push(msg.sender);
        lottery.prizePool += msg.value;
        hasParticipated[_lotteryId][msg.sender] = true;
        userParticipations[msg.sender]++;

        emit LotteryJoined(_lotteryId, msg.sender, lottery.participants.length);

        // Auto-end lottery if max participants reached
        if (lottery.participants.length >= lottery.maxParticipants) {
            _endLottery(_lotteryId);
        }
    }

    /// End a lottery manually (only if time has passed or max participants reached)
    function endLottery(uint256 _lotteryId) external lotteryExists(_lotteryId) {
        Lottery storage lottery = lotteries[_lotteryId];
        
        if (!lottery.isActive) {
            revert LotteryErrors.LotteryNotActive();
        }
        if (block.timestamp < lottery.endTime && lottery.participants.length < lottery.maxParticipants) {
            revert LotteryErrors.LotteryInProgress();
        }

        _endLottery(_lotteryId);
    }

    /// Internal function to end a lottery and request random number
    function _endLottery(uint256 _lotteryId) internal {
        Lottery storage lottery = lotteries[_lotteryId];
        
        if (lottery.participants.length == 0) {
            revert LotteryErrors.NoParticipants();
        }

        lottery.isActive = false;
        
        // If only one participant, they win by default
        if (lottery.participants.length == 1) {
            lottery.winner = lottery.participants[0];
            lottery.isEnded = true;
            userWinnings[lottery.winner] += lottery.prizePool;
            totalPrizesDistributed += lottery.prizePool;
            
            emit LotteryEnded(_lotteryId, lottery.winner, lottery.prizePool, 0);
            return;
        }

        // Request random number from Pyth Entropy
        uint256 fee = entropy.getFeeV2();
        uint64 sequenceNumber = entropy.requestV2{value: fee}();
        
        lottery.sequenceNumber = sequenceNumber;
        emit RandomNumberRequested(_lotteryId, sequenceNumber);
    }

    /// Callback function called by Pyth Entropy when random number is generated
    function entropyCallback(
        uint64 sequenceNumber,
        address,
        bytes32 randomNumber
    ) internal override {
        // Find the lottery with this sequence number
        for (uint256 i = 0; i < nextLotteryId; i++) {
            Lottery storage lottery = lotteries[i];
            if (lottery.sequenceNumber == sequenceNumber && !lottery.randomNumberReceived) {
                lottery.randomNumberReceived = true;
                _selectWinner(i, randomNumber);
                break;
            }
        }
    }

    /// Select winner based on random number
    function _selectWinner(uint256 _lotteryId, bytes32 _randomNumber) internal {
        Lottery storage lottery = lotteries[_lotteryId];
        
        uint256 randomIndex = uint256(_randomNumber) % lottery.participants.length;
        lottery.winner = lottery.participants[randomIndex];
        lottery.isEnded = true;
        
        userWinnings[lottery.winner] += lottery.prizePool;
        totalPrizesDistributed += lottery.prizePool;
        
        emit LotteryEnded(_lotteryId, lottery.winner, lottery.prizePool, lottery.sequenceNumber);
    }

    /// Claim prize (winner can claim their winnings)
    function claimPrize(uint256 _lotteryId) external lotteryExists(_lotteryId) {
        Lottery storage lottery = lotteries[_lotteryId];
        
        if (!lottery.isEnded) {
            revert LotteryErrors.LotteryInProgress();
        }
        if (lottery.winner != msg.sender) {
            revert LotteryErrors.NotOwner();
        }
        if (lottery.prizePool == 0) {
            revert LotteryErrors.InsufficientFee();
        }

        uint256 prizeAmount = lottery.prizePool;
        lottery.prizePool = 0;
        
        (bool success, ) = payable(msg.sender).call{value: prizeAmount}("");
        require(success, "Transfer failed");
        
        emit PrizeClaimed(_lotteryId, msg.sender, prizeAmount);
    }

    /// Get lottery information
    function getLottery(uint256 _lotteryId) external view lotteryExists(_lotteryId) returns (
        uint256 lotteryId,
        uint256 entryFee,
        uint256 maxParticipants,
        uint256 startTime,
        uint256 endTime,
        uint256 prizePool,
        uint256 participantCount,
        address winner,
        bool isActive,
        bool isEnded,
        uint64 sequenceNumber
    ) {
        Lottery storage lottery = lotteries[_lotteryId];
        return (
            lottery.lotteryId,
            lottery.entryFee,
            lottery.maxParticipants,
            lottery.startTime,
            lottery.endTime,
            lottery.prizePool,
            lottery.participants.length,
            lottery.winner,
            lottery.isActive,
            lottery.isEnded,
            lottery.sequenceNumber
        );
    }

    /// Get lottery participants
    function getLotteryParticipants(uint256 _lotteryId) external view lotteryExists(_lotteryId) returns (address[] memory) {
        return lotteries[_lotteryId].participants;
    }

    /// Get user statistics
    function getUserStats(address _user) external view returns (
        uint256 winnings,
        uint256 participations
    ) {
        return (userWinnings[_user], userParticipations[_user]);
    }

    /// Get contract statistics
    function getContractStats() external view returns (
        uint256 totalLotteries_,
        uint256 totalPrizesDistributed_,
        uint256 currentLotteryId
    ) {
        return (totalLotteries, totalPrizesDistributed, nextLotteryId);
    }

    /// Get entropy fee
    function getEntropyFee() public view returns (uint256) {
        return entropy.getFeeV2();
    }

    /// Required by IEntropyConsumer interface
    function getEntropy() internal view override returns (address) {
        return address(entropy);
    }

    /// Emergency functions (only owner)
    function emergencyWithdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function setEntropyProvider(address _newProvider) external onlyOwner {
        entropyProvider = _newProvider;
    }

    receive() external payable {}
}
